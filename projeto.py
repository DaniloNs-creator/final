import streamlit as st
import sqlite3
from datetime import datetime, timedelta, date
import pandas as pd
import plotly.express as px
import random
from typing import List, Tuple, Optional
import io
import contextlib
import chardet
from io import BytesIO
import base64
import time
import xml.etree.ElementTree as ET
import os
import hashlib
import xml.dom.minidom
import traceback
from pathlib import Path

# --- CONFIGURA√á√ÉO INICIAL ---
st.set_page_config(
    page_title="Sistema de Processamento",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Namespaces para CT-e
CTE_NAMESPACES = {
    'cte': 'http://www.portalfiscal.inf.br/cte'
}

# Inicializa√ß√£o do estado da sess√£o
if 'selected_xml' not in st.session_state:
    st.session_state.selected_xml = None
if 'cte_data' not in st.session_state:
    st.session_state.cte_data = None

# --- FUN√á√ïES DO PROCESSADOR DE ARQUIVOS ---
def processador_txt():
    st.title("üìÑ Processador de Arquivos TXT")
    st.markdown("""
    <div class="card">
        Remova linhas indesejadas de arquivos TXT. Carregue seu arquivo e defina os padr√µes a serem removidos.
    </div>
    """, unsafe_allow_html=True)

    def detectar_encoding(conteudo):
        """Detecta o encoding do conte√∫do do arquivo"""
        resultado = chardet.detect(conteudo)
        return resultado['encoding']

    def processar_arquivo(conteudo, padroes):
        """
        Processa o conte√∫do do arquivo removendo linhas indesejadas e realizando substitui√ß√µes
        """
        try:
            # Dicion√°rio de substitui√ß√µes
            substituicoes = {
                "IMPOSTO IMPORTACAO": "IMP IMPORT",
                "TAXA SICOMEX": "TX SISCOMEX",
                "FRETE INTERNACIONAL": "FRET INTER",
                "SEGURO INTERNACIONAL": "SEG INTERN"
            }
            
            # Detecta o encoding
            encoding = detectar_encoding(conteudo)
            
            # Decodifica o conte√∫do
            try:
                texto = conteudo.decode(encoding)
            except UnicodeDecodeError:
                texto = conteudo.decode('latin-1')
            
            # Processa as linhas
            linhas = texto.splitlines()
            linhas_processadas = []
            
            for linha in linhas:
                linha = linha.strip()
                # Verifica se a linha cont√©m algum padr√£o a ser removido
                if not any(padrao in linha for padrao in padroes):
                    # Aplica as substitui√ß√µes
                    for original, substituto in substituicoes.items():
                        linha = linha.replace(original, substituto)
                    linhas_processadas.append(linha)
            
            return "\n".join(linhas_processadas), len(linhas)
        
        except Exception as e:
            st.error(f"Erro ao processar o arquivo: {str(e)}")
            return None, 0

    # Padr√µes padr√£o para remo√ß√£o
    padroes_default = ["-------", "SPED EFD-ICMS/IPI"]
    
    # Upload do arquivo
    arquivo = st.file_uploader("Selecione o arquivo TXT", type=['txt'])
    
    # Op√ß√µes avan√ßadas
    with st.expander("‚öôÔ∏è Configura√ß√µes avan√ßadas", expanded=False):
        padroes_adicionais = st.text_input(
            "Padr√µes adicionais para remo√ß√£o (separados por v√≠rgula)",
            help="Exemplo: padr√£o1, padr√£o2, padr√£o3"
        )
        
        padroes = padroes_default + [
            p.strip() for p in padroes_adicionais.split(",") 
            if p.strip()
        ] if padroes_adicionais else padroes_default

    if arquivo is not None:
        try:
            # L√™ o conte√∫do do arquivo
            conteudo = arquivo.read()
            
            # Processa o arquivo
            resultado, total_linhas = processar_arquivo(conteudo, padroes)
            
            if resultado is not None:
                # Mostra estat√≠sticas
                linhas_processadas = len(resultado.splitlines())
                st.success(f"""
                **Processamento conclu√≠do!**  
                ‚úîÔ∏è Linhas originais: {total_linhas}  
                ‚úîÔ∏è Linhas processadas: {linhas_processadas}  
                ‚úîÔ∏è Linhas removidas: {total_linhas - linhas_processadas}
                """)

                # Pr√©via do resultado
                st.subheader("Pr√©via do resultado")
                st.text_area("Conte√∫do processado", resultado, height=300)

                # Bot√£o de download
                buffer = BytesIO()
                buffer.write(resultado.encode('utf-8'))
                buffer.seek(0)
                
                st.download_button(
                    label="‚¨áÔ∏è Baixar arquivo processado",
                    data=buffer,
                    file_name=f"processado_{arquivo.name}",
                    mime="text/plain"
                )
        
        except Exception as e:
            st.error(f"Erro inesperado: {str(e)}")
            st.info("Tente novamente ou verifique o arquivo.")

# --- PROCESSADOR CT-E SEM ARMAZENAMENTO ---
class CTeProcessorDirect:
    def __init__(self):
        self.processed_data = []
    
    def extract_cte_data(self, xml_content, filename):
        """Extrai dados espec√≠ficos do CT-e diretamente para planilha"""
        try:
            root = ET.fromstring(xml_content)
            
            # Registra namespaces
            for prefix, uri in CTE_NAMESPACES.items():
                ET.register_namespace(prefix, uri)
            
            # Fun√ß√£o auxiliar para encontrar texto com namespaces
            def find_text(element, xpath):
                try:
                    for prefix, uri in CTE_NAMESPACES.items():
                        full_xpath = xpath.replace('cte:', f'{{{uri}}}')
                        found = element.find(full_xpath)
                        if found is not None and found.text:
                            return found.text
                    
                    # Tentativa alternativa sem namespace
                    found = element.find(xpath.replace('cte:', ''))
                    if found is not None and found.text:
                        return found.text
                        
                    return None
                except Exception:
                    return None
            
            # Extrai dados espec√≠ficos do CT-e
            nCT = find_text(root, './/cte:nCT')
            dhEmi = find_text(root, './/cte:dhEmi')
            cMunIni = find_text(root, './/cte:cMunIni')
            UFIni = find_text(root, './/cte:UFIni')
            cMunFim = find_text(root, './/cte:cMunFim')
            UFFim = find_text(root, './/cte:UFFim')
            emit_xNome = find_text(root, './/cte:emit/cte:xNome')
            vTPrest = find_text(root, './/cte:vTPrest')
            rem_xNome = find_text(root, './/cte:rem/cte:xNome')
            
            # Extrai chave da NFe associada (se existir)
            infNFe_chave = find_text(root, './/cte:infNFe/cte:chave')
            
            # Extrai apenas o n√∫mero da NFe da chave de acesso (√∫ltimos 9 d√≠gitos)
            numero_nfe = None
            if infNFe_chave and len(infNFe_chave) >= 9:
                numero_nfe = infNFe_chave[-9:]
            
            # Formata data no padr√£o DD/MM/AA
            data_formatada = None
            if dhEmi:
                try:
                    # Tenta diferentes formatos de data
                    try:
                        data_obj = datetime.strptime(dhEmi[:10], '%Y-%m-%d')
                    except:
                        data_obj = datetime.strptime(dhEmi[:10], '%d/%m/%Y')
                    
                    data_formatada = data_obj.strftime('%d/%m/%y')
                except:
                    data_formatada = dhEmi[:10]  # Fallback para formato original
            
            # Converte valor para decimal
            try:
                vTPrest = float(vTPrest) if vTPrest else 0.0
            except (ValueError, TypeError):
                vTPrest = 0.0
            
            # Retorna os dados estruturados
            return {
                'Arquivo': filename,
                'nCT': nCT or 'N/A',
                'Data Emiss√£o': data_formatada or dhEmi or 'N/A',
                'C√≥digo Munic√≠pio In√≠cio': cMunIni or 'N/A',
                'UF In√≠cio': UFIni or 'N/A',
                'C√≥digo Munic√≠pio Fim': cMunFim or 'N/A',
                'UF Fim': UFFim or 'N/A',
                'Emitente': emit_xNome or 'N/A',
                'Valor Presta√ß√£o': vTPrest,
                'Remetente': rem_xNome or 'N/A',
                'Chave NFe': infNFe_chave or 'N/A',
                'N√∫mero NFe': numero_nfe or 'N/A',
                'Data Processamento': datetime.now().strftime('%d/%m/%Y %H:%M:%S')
            }
            
        except Exception as e:
            st.error(f"Erro ao extrair dados do CT-e {filename}: {str(e)}")
            return None
    
    def process_single_file(self, uploaded_file):
        """Processa um √∫nico arquivo XML de CT-e"""
        try:
            file_content = uploaded_file.getvalue()
            filename = uploaded_file.name
            
            # Verifica se √© um XML
            if not filename.lower().endswith('.xml'):
                return False, "Arquivo n√£o √© XML"
            
            # Verifica se √© um CT-e
            content_str = file_content.decode('utf-8', errors='ignore')
            if 'CTe' not in content_str and 'conhecimento' not in content_str.lower():
                return False, "Arquivo n√£o parece ser um CT-e"
            
            # Extrai dados
            cte_data = self.extract_cte_data(content_str, filename)
            
            if cte_data:
                self.processed_data.append(cte_data)
                return True, f"CT-e {filename} processado com sucesso!"
            else:
                return False, f"Erro ao processar CT-e {filename}"
                
        except Exception as e:
            return False, f"Erro ao processar arquivo {filename}: {str(e)}"
    
    def process_multiple_files(self, uploaded_files):
        """Processa m√∫ltiplos arquivos XML de CT-e"""
        results = {
            'success': 0,
            'errors': 0,
            'messages': []
        }
        
        for uploaded_file in uploaded_files:
            success, message = self.process_single_file(uploaded_file)
            if success:
                results['success'] += 1
            else:
                results['errors'] += 1
            results['messages'].append(message)
        
        return results
    
    def get_dataframe(self):
        """Retorna os dados processados como DataFrame"""
        if self.processed_data:
            return pd.DataFrame(self.processed_data)
        return pd.DataFrame()
    
    def clear_data(self):
        """Limpa os dados processados"""
        self.processed_data = []

def processador_cte():
    """Interface para o sistema de CT-e sem armazenamento"""
    # Inicializar processador
    processor = CTeProcessorDirect()
    
    st.title("üöö Processador de CT-e para Power BI")
    st.markdown("### Processa arquivos XML de CT-e e gera planilha para an√°lise")
    
    # Navega√ß√£o por abas
    tab1, tab2, tab3 = st.tabs(["Upload", "Visualizar Dados", "Exportar"])
    
    with tab1:
        st.header("Upload de CT-es")
        upload_option = st.radio("Selecione o tipo de upload:", 
                                ["Upload Individual", "Upload em Lote"])
        
        if upload_option == "Upload Individual":
            uploaded_file = st.file_uploader("Selecione um arquivo XML de CT-e", type=['xml'], key="single_cte")
            if uploaded_file and st.button("üìä Processar CT-e", key="process_single"):
                with st.spinner("Processando CT-e..."):
                    success, message = processor.process_single_file(uploaded_file)
                    if success:
                        st.success(message)
                    else:
                        st.error(message)
        
        else:
            uploaded_files = st.file_uploader("Selecione m√∫ltiplos arquivos XML de CT-e", 
                                            type=['xml'], 
                                            accept_multiple_files=True,
                                            key="multiple_cte")
            if uploaded_files and st.button("üìä Processar Todos", key="process_multiple"):
                with st.spinner(f"Processando {len(uploaded_files)} CT-es..."):
                    results = processor.process_multiple_files(uploaded_files)
                    
                    st.success(f"""
                    **Processamento conclu√≠do!**  
                    ‚úÖ Sucessos: {results['success']}  
                    ‚ùå Erros: {results['errors']}
                    """)
                    
                    if results['errors'] > 0:
                        with st.expander("Ver mensagens detalhadas"):
                            for msg in results['messages']:
                                st.write(f"- {msg}")
        
        # Bot√£o para limpar dados
        if st.button("üóëÔ∏è Limpar Dados Processados", type="secondary"):
            processor.clear_data()
            st.success("Dados limpos com sucesso!")
            st.rerun()
    
    with tab2:
        st.header("Dados Processados")
        df = processor.get_dataframe()
        
        if not df.empty:
            st.write(f"Total de CT-es processados: {len(df)}")
            
            # Filtros
            col1, col2 = st.columns(2)
            with col1:
                uf_filter = st.multiselect("Filtrar por UF In√≠cio", options=df['UF In√≠cio'].unique())
            with col2:
                emitente_filter = st.multiselect("Filtrar por Emitente", options=df['Emitente'].unique())
            
            # Aplicar filtros
            filtered_df = df.copy()
            if uf_filter:
                filtered_df = filtered_df[filtered_df['UF In√≠cio'].isin(uf_filter)]
            if emitente_filter:
                filtered_df = filtered_df[filtered_df['Emitente'].isin(emitente_filter)]
            
            # Exibir dataframe
            st.dataframe(filtered_df, use_container_width=True)
            
            # Estat√≠sticas
            st.subheader("üìà Estat√≠sticas")
            col1, col2, col3 = st.columns(3)
            
            col1.metric("Total Valor Presta√ß√£o", f"R$ {filtered_df['Valor Presta√ß√£o'].sum():,.2f}")
            col2.metric("M√©dia por CT-e", f"R$ {filtered_df['Valor Presta√ß√£o'].mean():,.2f}")
            col3.metric("Maior Valor", f"R$ {filtered_df['Valor Presta√ß√£o'].max():,.2f}")
            
        else:
            st.info("Nenhum CT-e processado ainda. Fa√ßa upload de arquivos na aba 'Upload'.")
    
    with tab3:
        st.header("Exportar para Excel")
        df = processor.get_dataframe()
        
        if not df.empty:
            st.success(f"Pronto para exportar {len(df)} registros")
            
            # Op√ß√µes de exporta√ß√£o
            export_option = st.radio("Formato de exporta√ß√£o:", 
                                   ["Excel (.xlsx)", "CSV (.csv)"])
            
            if export_option == "Excel (.xlsx)":
                # Gerar Excel
                output = BytesIO()
                with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                    df.to_excel(writer, sheet_name='Dados_CTe', index=False)
                
                output.seek(0)
                
                st.download_button(
                    label="üì• Baixar Planilha Excel",
                    data=output,
                    file_name="dados_cte.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )
            
            else:
                # Gerar CSV
                csv = df.to_csv(index=False).encode('utf-8')
                
                st.download_button(
                    label="üì• Baixar Arquivo CSV",
                    data=csv,
                    file_name="dados_cte.csv",
                    mime="text/csv"
                )
            
            # Pr√©via dos dados
            with st.expander("üìã Pr√©via dos dados a serem exportados"):
                st.dataframe(df.head(10))
                
        else:
            st.warning("Nenhum dado dispon√≠vel para exporta√ß√£o.")

# --- CSS E CONFIGURA√á√ÉO DE ESTILO ---
def load_css():
    st.markdown("""
    <style>
        .cover-container {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ed 100%);
            padding: 3rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            text-align: center;
        }
        .cover-title {
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #2c3e50, #3498db);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .header {
            font-size: 1.8rem;
            font-weight: 700;
            margin: 1.5rem 0 1rem 0;
            padding-left: 10px;
            border-left: 5px solid #2c3e50;
        }
        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            padding: 1.8rem;
            margin-bottom: 1.8rem;
        }
        .stButton>button {
            width: 100%;
        }
    </style>
    """, unsafe_allow_html=True)

# --- APLICA√á√ÉO PRINCIPAL ---
def main():
    """Fun√ß√£o principal que gerencia o fluxo da aplica√ß√£o."""
    load_css()
    
    # Mostrar capa
    st.markdown("""
    <div class="cover-container">
        <h1 class="cover-title">Sistema de Processamento de Arquivos</h1>
        <p class="cover-subtitle">Processamento de TXT e CT-e para an√°lise de dados</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Menu de navega√ß√£o
    tab1, tab2 = st.tabs(["üìÑ Processador TXT", "üöö Processador CT-e"])
    
    with tab1:
        processador_txt()
    
    with tab2:
        processador_cte()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        st.error(f"Ocorreu um erro inesperado: {str(e)}")
        st.code(traceback.format_exc())